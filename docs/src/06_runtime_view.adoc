ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View


ifdef::arc42help[]
[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the systemâ€™s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...


.Further Information

See https://docs.arc42.org/section-6/[Runtime View] in the arc42 documentation.

****
endif::arc42help[]
=== Sign In
A user wants to create a new account. The user introduces the required information and clicks the "Sign In" button. The system validates the information and creates a new account. If all the process runs correctly, the system logs in the user and redirects to the main page.
[plantuml,"SignIn diagram",svg]
----
actor User
collections WebApp
collections GatewayService
collections UserService
database DB as "MongoDB"

User -> WebApp: Request sign in
WebApp -> GatewayService: SignInRequest(UserData)
GatewayService  -> UserService: SignInRequest(UserData)
UserService -> UserService: validateFields()
UserService  -> DB: validateRequiredFieldsAndInsert()
DB -> UserService: Confirm data
UserService -> UserService: loginUser()
UserService -> GatewayService: Confirm sign in
GatewayService -> WebApp: Confirm sign in
WebApp -> User: Confirm sign in
----

=== Log In
A user wants to log in into the application. The user introduces the required information and clicks the "Log In" button. The system validates the information and if the user had already an account, redirects them to the main page.
[plantuml,"LogIn diagram",svg]
----
actor User
collections WebApp
collections GatewayService
collections AuthService
database DB as "MongoDB"

User -> WebApp: Request login
WebApp -> GatewayService: LogInRequest(UserData)
GatewayService  -> AuthService: LogInRequest(UserData)
AuthService -> AuthService: validateFields()
AuthService  -> DB: logInUser()
DB -> AuthService: Confirm data
AuthService -> AuthService: loginUser()
AuthService -> GatewayService: Confirm login
GatewayService -> WebApp: Confirm login
WebApp -> User: Confirm login
----

=== Generate Questions
The admin wants to generate new questions to be stored in the database for later use during gameplay. This process is handled in the backend, using the Wikidata API to retrieve relevant data.
[plantuml,"New question",svg]
----
actor Admin
collections QUS as "WikiQuestionService"
collections QM as "QuestionManager"
collections CL as "CategoryLoader"
collections QG as "QuestionGen"
entity WD as "WikidataAPI"
database DB as "MongoDB"

Admin -> QUS: generateQuestions()
QUS -> QM: loadAllQuestions(topics,numQuestions)
QM -> CL: new CategoryLoader(topics,numQuestions)
CL -> QG: new WikidataQueryService(categoryName,entity,properties,questions,types,img,categoryQuestions)
QG -> QG: generateQuestions()
QG -> WD: obtenerIdsDeWikidata(quantity)
WD -> QG: Ids
QG -> QG: generarDescripcion(entity_id, randomIndex)
QG -> WD: obtenerValoresDePropiedad(id,property,type,language)
WD -> QG: Property Values
QG -> QG: obtenerRespuestasIncorrectas(entityId,property,propertyValues,type,language)
QG -> CL: WikidataQueryService
CL -> QM: CategoryLoader
QM -> QUS: Questions
QUS -> DB: saveQuestionsToDB(questions)
----

=== New Clue
A user wants to get a new clue for the current question. The GameService cheks if all the conditions are met and asks the LLMService for a new clue. The LLMService validates the clue and returns it to the GameService, which sends it to the GatewayService and finally to the WebApp.
[plantuml,"New clue",svg]
----
actor User
collections WA as "Web App"
collections GW as "GatewayService"
collections QU as "GameService"
collections LLMS as "LLMService"
entity LLM as "EmpathyAPI"

User -> WA: Asks for a question
WA -> GW: userAsksForNewClue(userText)
GW -> QU: userAsksForNewClue(userText)
QU -> LLMS: getNewClue(userText)
LLMS -> LLMS: validateClue(userText)
LLMS -> LLM: getClue(userText)
LLM -> LLMS: LLM Answer
LLMS -> QU: Clue Data
QU -> GW: Clue Data
GW -> WA: Clue Data
----

=== Get Ranking and stats from the top player
The user accesses the player ranking via the web application. The request is routed through the gateway to the statsservice, which fetches and returns the ranking data. The user then selects the top player to view detailed statistics, which are also retrieved from the statsservice and displayed in the UI.
[plantuml,"Question record",svg]
----
actor User
collections WA as "Web App"
collections GW as "GatewayService"
collections SS as "StatsService"
database DB as "MongoDB"

User -> WA: Access ranking page
WA -> GW: /getranking
GW -> SS: /getranking
SS -> DB: Stats.find().sort({ maxScore: -1, ratio: -1 }) .limit(10);
DB -> SS: Top Players Stats
SS -> GW: Top Players Stats
GW -> WA: Top Payers Stats
User -> WA: Access top player page
WA -> GW: /getstats/:topPlayerUsername
GW -> SS: /getstats/:topPlayerUsername
SS -> DB: Stats.findOne({ topPlayerUsername })
DB -> SS: Top Player Stats
SS -> GW: Top Player Stats
GW -> WA: Top Player Stats

----